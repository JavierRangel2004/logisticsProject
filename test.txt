Check these python files that process a data set from amazon products. lets modify main2.py and models2.py to do the next things:
Create new data following the most optimal and usefull design usign csvs
Tune and refine the models of forecasting to take the new data and use it completly
Check that the data makes sense, assume that this is a real case scenario so the data needs to be as close to the reality or at least the format of the data
Add a new csv that saves the last forecast of the models
ABC analysis in another csv
20% of SKUs represents 80% of the total sale
1. Calculate annual usage in units
2. Multiply it by its unit cost
3. Sort it from highest to lowest
4. Assign ABC categories
A: 80% of total sale
B = 80.01 % to 95%
C = 95% to 100%

Add a inventory analysis in another csv
Use multiple period inventory model or single period model to calculate the reorder point and safety stock

The objective of the project is to develop a program that provides this complete data creation and analysis process centered in logistics and inventory management
Respond with the modified main2.py that does the data load creation and save and imports models2 to forecast and save the forecast in a new csv, the ABC analysis in another csv and the inventory analysis in another csv
And create save all the csv in a new folder called results and data
Suggestes data:
To align the dataset with Amazonâ€™s demand forecasting and inventory optimization requirements, I'll create an **entity-relationship diagram (ERD)** with new synthetic data fields necessary for analysis, incorporating both existing and additional data fields needed. This design will focus on ensuring all key aspects of demand forecasting and inventory management are covered.

---

### Proposed Data Model (ERD)

1. **Product**
   - **product_id**: Unique identifier for each product.
   - **product_name**: Name or description of the product.
   - **category**: Classification, e.g., Electronics, Books.
   - **price**: Price of the product.
   - **discounted_price**: Discounted or current sale price.
   - **rating**: Average customer rating.
   - **rating_count**: Number of ratings.
   - **inventory_level** (new): Current stock level.
   - **reorder_point** (new): Point at which a reorder is triggered.
   - **safety_stock** (new): Minimum inventory level to prevent stockouts.
   
2. **Sales**
   - **sales_id**: Unique identifier for each sales entry.
   - **product_id** (foreign key): Links to Product table.
   - **sales_volume** (new): Number of units sold.
   - **sales_date** (new): Date of each sale for time-series analysis.
   - **sales_season** (new): Indicates season or period, e.g., â€œHoliday Season.â€
   - **price_at_sale** (new): Product price at the time of sale.
   
3. **Customer**
   - **customer_id**: Unique identifier for each customer.
   - **region** (new): Customerâ€™s geographic region, crucial for regional demand trends.
   - **purchase_frequency** (new): Frequency of customer purchases.
   
4. **Review**
   - **review_id**: Unique identifier for each review.
   - **product_id** (foreign key): Links to Product table.
   - **customer_id** (foreign key): Links to Customer table.
   - **rating**: Product rating given in this review.
   - **review_date**: Date the review was posted.
   - **sentiment** (new): Analysis of the reviewâ€™s sentiment (positive, neutral, negative).
   
5. **Demand_Forecasting**
   - **forecast_id**: Unique identifier for each forecast entry.
   - **product_id** (foreign key): Links to Product table.
   - **forecast_date**: Date of the forecast.
   - **predicted_demand** (new): Forecasted sales volume.
   - **model_used** (new): Model applied (e.g., ARIMA, Random Forest).
   
---

### Explanation of the New Fields

- **sales_date** and **sales_season** are critical for time-series analysis, allowing for seasonality and trend detection.
- **inventory_level**, **reorder_point**, and **safety_stock** are essential for maintaining optimal stock levels, preventing overstocking, and managing inventory efficiently.
- **region** and **purchase_frequency** help in demand forecasting and customer behavior analysis.
- **sentiment** in reviews enables demand forecasting based on customer satisfaction, enhancing demand prediction accuracy.
  
Let me know if you'd like to proceed with creating synthetic data for these fields or if any specific adjustments to this model are required.


amazon.csv
product_id,product_name,category,discounted_price,actual_price,discount_percentage,rating,rating_count,about_product,user_id,user_name,review_id,review_title,review_content,img_link,product_link
B07JW9H4J1,"Wayona Nylon Braided USB to Lightning Fast Charging and Data Sync Cable Compatible for iPhone 13, 12,11, X, 8, 7, 6, 5, iPad Air, Pro, Mini (3 FT Pack of 1, Grey)",Computers&Accessories|Accessories&Peripherals|Cables&Accessories|Cables|USBCables,â‚¹399,"â‚¹1,099",64%,4.2,"24,269","High Compatibility : Compatible With iPhone 12, 11, X/XsMax/Xr ,iPhone 8/8 Plus,iPhone 7/7 Plus,iPhone 6s/6s Plus,iPhone 6/6 Plus,iPhone 5/5s/5c/se,iPad Pro,iPad Air 1/2,iPad mini 1/2/3,iPod nano7,iPod touch and more apple devices.|Fast Charge&Data Sync : It can charge and sync simultaneously at a rapid speed, Compatible with any charging adaptor, multi-port charging station or power bank.|Durability : Durable nylon braided design with premium aluminum housing and toughened nylon fiber wound tightly around the cord lending it superior durability and adding a bit to its flexibility.|High Security Level : It is designed to fully protect your device from damaging excessive current.Copper core thick+Multilayer shielding, Anti-interference, Protective circuit equipment.|WARRANTY: 12 months warranty and friendly customer services, ensures the long-time enjoyment of your purchase. If you meet any question or problem, please don't hesitate to contact us.","AG3D6O4STAQKAY2UVGEUV46KN35Q,AHMY5CWJMMK5BJRBBSNLYT3ONILA,AHCTC6ULH4XB6YHDY6PCH2R772LQ,AGYHHIERNXKA6P5T7CZLXKVPT7IQ,AG4OGOFWXJZTQ2HKYIOCOY3KXF2Q,AENGU523SXMOS7JPDTW52PNNVWGQ,AEQJHCVTNINBS4FKTBGQRQTGTE5Q,AFC3FFC5PKFF5PMA52S3VCHOZ5FQ","Manav,Adarsh gupta,Sundeep,S.Sayeed Ahmed,jaspreet singh,Khaja moin,Anand,S.ARUMUGAM","R3HXWT0LRP0NMF,R2AJM3LFTLZHFO,R6AQJGUP6P86,R1KD19VHEDV0OR,R3C02RMYQMK6FC,R39GQRVBUZBWGY,R2K9EDOE15QIRJ,R3OI7YT648TL8I","Satisfied,Charging is really fast,Value for money,Product review,Good quality,Good product,Good Product,As of now seems good","Looks durable Charging is fine tooNo complains,Charging is really fast, good product.,Till now satisfied with the quality.,This is a good product . The charging speed is slower than the original iPhone cable,Good quality, would recommend,https://m.media-amazon.com/images/W/WEBP_402378-T1/images/I/81---F1ZgHL._SY88.jpg,Product had worked well till date and was having no issue.Cable is also sturdy enough...Have asked for replacement and company is doing the same...,Value for money",https://m.media-amazon.com/images/W/WEBP_402378-T1/images/I/51UsScvHQNL._SX300_SY300_QL70_FMwebp_.jpg,https://www.amazon.in/Wayona-Braided-WN3LG1-Syncing-Charging/dp/B07JW9H4J1/ref=sr_1_1?qid=1672909124&s=electronics&sr=1-1
B098NS6PVG,"Ambrane Unbreakable 60W / 3A Fast Charging 1.5m Braided Type C Cable for Smartphones, Tablets, Laptops & other Type C devices, PD Technology, 480Mbps Data Sync, Quick Charge 3.0 (RCT15A, Black)",Computers&Accessories|Accessories&Peripherals|Cables&Accessories|Cables|USBCables,â‚¹199,â‚¹349,43%,4.0,"43,994","Compatible with all Type C enabled devices, be it an android smartphone (Mi, Samsung, Oppo, Vivo, Realme, OnePlus, etc), tablet, laptop (Macbook, Chromebook, etc)|Supports Quick Charging (2.0/3.0)|Unbreakable â€“ Made of special braided outer with rugged interior bindings, it is ultra-durable cable that wonâ€™t be affected by daily rough usage|Ideal Length â€“ It has ideal length of 1.5 meters which is neither too short like your typical 1meter cable or too long like a 2meters cable|Supports maximum 3A fast charging and 480 Mbps data transfer speed|6 months manufacturer warranty from the date of purchase","AECPFYFQVRUWC3KGNLJIOREFP5LQ,AGYYVPDD7YG7FYNBXNGXZJT525AQ,AHONIZU3ICIEHQIGQ6R2VFRSBXOQ,AFPHD2CRPDZMWMBL7WXRSVYWS5JA,AEZ346GX3HJ4O4XNRPHCNHXQURMQ,AEPSWFPNECKO34PUC7I56ITGXR6Q,AHWVEHR5DYLVFTO2KF3IZATFQSWQ,AH4QT33M55677I7ISQOAKEQWACYQ","ArdKn,Nirbhay kumar,Sagar Viswanathan,Asp,Placeholder,BharanI,sonia,Niam","RGIQEG07R9HS2,R1SMWZQ86XIN8U,R2J3Y1WL29GWDE,RYGGS0M09S3KY,R17KQRUTAN5DKS,R3AAQGS6HP2QUK,R1HDNOG6TO2CCA,R3PHKXYA5AFEOU","A Good Braided Cable for Your Type C Device,Good quality product from ambrane,Super cable,As,Good quality,Good product,its good,Good quality for the price but one issue with my unit","I ordered this cable to connect my phone to Android Auto of car. The cable is really strong and the connection ports are really well made. I already has a Micro USB cable from Ambrane and it's still in good shape. I connected my phone to the car using the cable and it got connected well and no issues. I also connected it to the charging port and yes it has Fast Charging support.,It quality is good at this price and the main thing is that i didn't ever thought that this cable will be so long it's good one and charging power is too good and also supports fast charging,Value for money, with extra lengthðŸ‘,Good, working fine,Product quality is good,Good,very good,Bought for my daughter's old phone.Brand new cable it was not charging, I already repacked and requested for replacement.I checked again, and there was some green colour paste/fungus inside the micro USB connector. I cleaned with an alcoholic and starts working again.Checked the ampere of charging speed got around 1400ma-1500ma - not bad, came with braided 1.5m long cable, pretty impressive for the price.Can't blame the manufacturer.But quality issues by the distributor, they might have stored in very humid place.",https://m.media-amazon.com/images/W/WEBP_402378-T2/images/I/31zOsqQOAOL._SY445_SX342_QL70_FMwebp_.jpg,https://www.amazon.in/Ambrane-Unbreakable-Charging-Braided-Cable/dp/B098NS6PVG/ref=sr_1_2?qid=1672909124&s=electronics&sr=1-2


main2.py
# main2.py

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings
from datetime import datetime, timedelta

# Suppress warnings for cleaner output
warnings.filterwarnings("ignore")


def preprocess_and_generate_synthetic_data(input_file, products_output, sales_output, historicSalestoGenerate):
    """
    Preprocesses the Amazon Sales Dataset, separates product attributes and sales data,
    generates synthetic time series sales data, and calculates financial metrics.

    Parameters:
    - input_file: Path to the input CSV file (amazon.csv).
    - products_output: Path where the products CSV will be saved.
    - sales_output: Path where the sales CSV with financials will be saved.
    - historicSalestoGenerate: Total number of weeks to generate.
    """
    # Load the data
    df = pd.read_csv(input_file)

    # Define columns to keep for products
    product_columns = [
        'product_id',
        'product_name',
        'category',
        'discounted_price',
        'actual_price',
        'discount_percentage',
        'rating',
        'rating_count'
    ]

    # Extract product attributes
    products_df = df[product_columns].drop_duplicates()

    # Clean price columns
    price_columns = ['discounted_price', 'actual_price']
    for col in price_columns:
        products_df[col] = products_df[col].astype(str).str.replace(
            'â‚¹', '').str.replace(',', '').astype(float)

    # Clean discount_percentage
    products_df['discount_percentage'] = products_df['discount_percentage'].astype(
        str).str.replace('%', '').astype(float)

    # Clean rating
    products_df['rating'] = pd.to_numeric(
        products_df['rating'], errors='coerce')

    # Clean rating_count
    products_df['rating_count'] = products_df['rating_count'].astype(
        str).str.replace(',', '').astype(float).astype('Int64')
    median_rating_count = products_df['rating_count'].median()
    products_df['rating_count'] = products_df['rating_count'].fillna(
        median_rating_count)

    # Extract main_category
    products_df['main_category'] = products_df['category'].str.split(
        '|').str[0]

    # Extract brand from product_name (assuming brand is the first word)
    products_df['brand'] = products_df['product_name'].str.split().str[0]

    # Select final product columns
    products_df = products_df[['product_id', 'product_name', 'main_category', 'brand',
                               'discounted_price', 'actual_price', 'discount_percentage',
                               'rating', 'rating_count']]

    # Convert to categorical types where appropriate
    products_df['main_category'] = products_df['main_category'].astype(
        'category')
    products_df['brand'] = products_df['brand'].astype('category')

    # Save the products dataset
    products_df.to_csv(products_output, index=False)
    print(f"\nProducts data saved to {products_output}")
    print(products_df.head())

    # Generate synthetic sales data
    # Define time range
    start_date = datetime(2023, 1, 1)
    periods = historicSalestoGenerate  # Total weeks to generate
    freq = 'W'  # Weekly frequency

    synthetic_sales = []

    for _, product in products_df.iterrows():
        product_id = product['product_id']
        main_category = product['main_category']
        brand = product['brand']
        price = product['discounted_price']
        rating = product['rating']
        rating_count = product['rating_count']

        # Simulate sales over time with some randomness
        for week in range(periods):
            date = start_date + timedelta(weeks=week)
            # Base sales influenced by price and rating
            base = max(1, 100 - (price / 10) + (rating * 10))
            # Introduce seasonality (e.g., higher sales in certain weeks)
            seasonal = 1 + 0.1 * np.sin(2 * np.pi * week / periods)
            # Random fluctuation
            random_factor = np.random.normal(1.0, 0.1)
            weekly_sales = max(0, int(base * seasonal * random_factor))
            synthetic_sales.append({
                'product_id': product_id,
                'date': date.strftime('%Y-%m-%d'),
                'weekly_sales': weekly_sales
            })

    sales_df = pd.DataFrame(synthetic_sales)

    # Feature Engineering
    sales_df['date'] = pd.to_datetime(sales_df['date'])
    sales_df['year'] = sales_df['date'].dt.year
    sales_df['month'] = sales_df['date'].dt.month
    sales_df['week'] = sales_df['date'].dt.isocalendar().week
    sales_df['day_of_week'] = sales_df['date'].dt.dayofweek
    sales_df['is_holiday_season'] = sales_df['month'].isin(
        [11, 12, 1, 2])  # Example: Nov-Feb as holiday season

    # Calculate Financial Metrics
    sales_df = sales_df.merge(products_df[[
                              'product_id', 'discounted_price', 'actual_price']], on='product_id', how='left')
    sales_df['earnings'] = sales_df['discounted_price'] * \
        sales_df['weekly_sales']
    sales_df['costs'] = sales_df['actual_price'] * sales_df['weekly_sales']
    sales_df['profit'] = sales_df['earnings'] - sales_df['costs']
    sales_df['profit_margin'] = (
        sales_df['profit'] / sales_df['earnings']) * 100
    sales_df['profit_margin'] = sales_df['profit_margin'].replace(
        [np.inf, -np.inf], 0).fillna(0)

    # Select relevant columns
    sales_financials_df = sales_df[['product_id', 'date', 'weekly_sales', 'earnings', 'costs', 'profit', 'profit_margin',
                                    'year', 'month', 'week', 'day_of_week', 'is_holiday_season']]

    # Save the sales dataset with financials
    sales_financials_df.to_csv(sales_output, index=False)
    print(f"\nSales data with financials saved to {sales_output}")
    print(sales_financials_df.head())


def extract_product_label(product_name, brand, max_words=3):
    """
    Extracts a label for the product by combining the brand and the first few words of the product name.

    Parameters:
    - product_name: The full name of the product.
    - brand: The brand of the product.
    - max_words: Maximum number of words to extract from the product name after the brand.

    Returns:
    - label: A string combining the brand and part of the product name.
    """
    # Remove the brand from the product name
    name_without_brand = product_name.replace(brand, '').strip()
    # Split the remaining name into words
    words = name_without_brand.split()
    # Take the first 'max_words' words
    extracted_words = ' '.join(words[:max_words])
    # Combine brand and extracted words
    label = f"{brand} {extracted_words}"
    return label


def main2():
    # Define Parameters
    historicSalestoGenerate = 52  # Total weeks to generate
    train_weeks = 20              # Number of weeks for training
    forecast_weeks = 4            # Number of weeks to forecast

    # Validate Parameters
    if train_weeks + forecast_weeks > historicSalestoGenerate:
        print(
            f"Error: train_weeks ({train_weeks}) + forecast_weeks ({forecast_weeks}) exceeds historicSalestoGenerate ({historicSalestoGenerate}).")
        return

    # Step 1: Preprocess and generate synthetic data
    input_file = 'amazon.csv'      # Replace with your actual input file path
    products_output = 'products2.csv'
    sales_output = 'sales2_financials.csv'
    # Uncomment the line below if you need to generate new synthetic data
    preprocess_and_generate_synthetic_data(
        input_file, products_output, sales_output, historicSalestoGenerate)

if __name__ == "__main__":
    main2()


models2.py
# models2.py

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from prophet import Prophet
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error
from xgboost import XGBRegressor
import warnings

# Suppress warnings for cleaner output
warnings.filterwarnings("ignore")

def extract_product_label(product_name, brand, max_words=3):
    """
    Extracts a label for the product by combining the brand and the first few words of the product name.

    Parameters:
    - product_name: The full name of the product.
    - brand: The brand of the product.
    - max_words: Maximum number of words to extract from the product name after the brand.

    Returns:
    - label: A string combining the brand and part of the product name.
    """
    # Remove the brand from the product name
    name_without_brand = product_name.replace(brand, '').strip()
    # Split the remaining name into words
    words = name_without_brand.split()
    # Take the first 'max_words' words
    extracted_words = ' '.join(words[:max_words])
    # Combine brand and extracted words
    label = f"{brand} {extracted_words}"
    return label

def train_arima_model(train_data, test_data, product_label):
    """
    Trains an ARIMA model and forecasts sales for the test period.

    Parameters:
    - train_data: Training DataFrame.
    - test_data: Testing DataFrame.
    - product_label: Label for the product for plotting.

    Returns:
    - forecast_df: DataFrame containing forecasted sales.
    """
    model = ARIMA(train_data['weekly_sales'], order=(5,1,0))
    model_fit = model.fit()
    forecast = model_fit.forecast(steps=len(test_data))

    # Create forecast DataFrame
    forecast_df = pd.DataFrame({
        'date': test_data['date'],
        'forecasted_sales': forecast.values
    })

    # Combine training and test data for continuous plot
    combined_data = pd.concat([train_data, test_data], ignore_index=True)

    # Plot
    plt.figure(figsize=(12,6))
    plt.plot(combined_data['date'], combined_data['weekly_sales'], label='Historical Sales', marker='o',color='blue')
    plt.plot(forecast_df['date'], forecast_df['forecasted_sales'], label='ARIMA Forecast', marker='x', color='red')
    plt.title(f'ARIMA Forecast vs Actual Sales for {product_label}')
    plt.xlabel('Date')
    plt.ylabel('Weekly Sales')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Calculate error metrics
    mae = mean_absolute_error(test_data['weekly_sales'], forecast)
    rmse = mean_squared_error(test_data['weekly_sales'], forecast, squared=False)
    print(f"ARIMA Model - MAE: {mae:.2f}, RMSE: {rmse:.2f}")

    return forecast_df

def train_prophet_model(train_data, test_data, product_label):
    """
    Trains a Prophet model and forecasts sales for the test period.

    Parameters:
    - train_data: Training DataFrame.
    - test_data: Testing DataFrame.
    - product_label: Label for the product for plotting.

    Returns:
    - forecast_df: DataFrame containing forecasted sales.
    """
    prophet_train = train_data.rename(columns={'date': 'ds', 'weekly_sales': 'y'})
    prophet_test = test_data.rename(columns={'date': 'ds', 'weekly_sales': 'y'})

    model = Prophet()
    model.add_regressor('is_holiday_season')
    model.fit(prophet_train[['ds', 'y', 'is_holiday_season']])

    # Prepare future dataframe (test period)
    future = prophet_test[['ds', 'is_holiday_season']]
    forecast = model.predict(future)

    # Create forecast DataFrame
    forecast_df = pd.DataFrame({
        'date': forecast['ds'],
        'forecasted_sales': forecast['yhat']
    })

    # Combine training and test data for continuous plot
    combined_data = pd.concat([train_data, test_data], ignore_index=True)

    # Plot
    plt.figure(figsize=(12,6))
    plt.plot(combined_data['date'], combined_data['weekly_sales'], label='Historical Sales', marker="o",color='blue')
    plt.plot(forecast_df['date'], forecast_df['forecasted_sales'], label='Prophet Forecast', marker='x', color='green')
    plt.title(f'Prophet Forecast vs Actual Sales for {product_label}')
    plt.xlabel('Date')
    plt.ylabel('Weekly Sales')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Calculate error metrics
    mae = mean_absolute_error(prophet_test['y'], forecast['yhat'])
    rmse = mean_squared_error(prophet_test['y'], forecast['yhat'], squared=False)
    print(f"Prophet Model - MAE: {mae:.2f}, RMSE: {rmse:.2f}")

    return forecast_df

def train_random_forest_model(train_data, test_data, product_label):
    """
    Trains a Random Forest model and forecasts sales for the test period.

    Parameters:
    - train_data: Training DataFrame.
    - test_data: Testing DataFrame.
    - product_label: Label for the product for plotting.

    Returns:
    - forecast_df: DataFrame containing forecasted sales.
    """
    features = ['discounted_price', 'actual_price', 'discount_percentage', 'rating', 
                'rating_count', 'month', 'week', 'is_holiday_season']
    X_train = train_data[features]
    y_train = train_data['weekly_sales']
    X_test = test_data[features]
    y_test = test_data['weekly_sales']

    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    predictions = model.predict(X_test)

    # Create forecast DataFrame
    forecast_df = pd.DataFrame({
        'date': test_data['date'],
        'forecasted_sales': predictions
    })

    # Combine training and test data for continuous plot
    combined_data = pd.concat([train_data, test_data], ignore_index=True)

    # Plot
    plt.figure(figsize=(12,6))
    plt.plot(combined_data['date'], combined_data['weekly_sales'], label='Historical Sales', color='blue')
    plt.plot(forecast_df['date'], forecast_df['forecasted_sales'], label='Random Forest Forecast', marker='x', color='orange')
    plt.title(f'Random Forest Forecast vs Actual Sales for {product_label}')
    plt.xlabel('Date')
    plt.ylabel('Weekly Sales')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Calculate error metrics
    mae = mean_absolute_error(y_test, predictions)
    rmse = mean_squared_error(y_test, predictions, squared=False)
    print(f"Random Forest Model - MAE: {mae:.2f}, RMSE: {rmse:.2f}")

    return forecast_df

def train_xgboost_model(train_data, test_data, product_label):
    """
    Trains an XGBoost model and forecasts sales for the test period.

    Parameters:
    - train_data: Training DataFrame.
    - test_data: Testing DataFrame.
    - product_label: Label for the product for plotting.

    Returns:
    - forecast_df: DataFrame containing forecasted sales.
    """
    features = ['discounted_price', 'actual_price', 'discount_percentage', 'rating', 
                'rating_count', 'month', 'week', 'is_holiday_season']
    X_train = train_data[features]
    y_train = train_data['weekly_sales']
    X_test = test_data[features]
    y_test = test_data['weekly_sales']

    model = XGBRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    predictions = model.predict(X_test)

    # Create forecast DataFrame
    forecast_df = pd.DataFrame({
        'date': test_data['date'],
        'forecasted_sales': predictions
    })

    # Combine training and test data for continuous plot
    combined_data = pd.concat([train_data, test_data], ignore_index=True)

    # Plot
    plt.figure(figsize=(12,6))
    plt.plot(combined_data['date'], combined_data['weekly_sales'], label='Historical Sales', color='blue')
    plt.plot(forecast_df['date'], forecast_df['forecasted_sales'], label='XGBoost Forecast', marker='x', color='purple')
    plt.title(f'XGBoost Forecast vs Actual Sales for {product_label}')
    plt.xlabel('Date')
    plt.ylabel('Weekly Sales')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Calculate error metrics
    mae = mean_absolute_error(y_test, predictions)
    rmse = mean_squared_error(y_test, predictions, squared=False)
    print(f"XGBoost Model - MAE: {mae:.2f}, RMSE: {rmse:.2f}")

    return forecast_df

def main():
    # Define Parameters
    historicSalestoGenerate = 52  # Total weeks to generate
    train_weeks = 20              # Number of weeks for training
    forecast_weeks = 4            # Number of weeks to forecast

    # Validate Parameters
    if train_weeks + forecast_weeks > historicSalestoGenerate:
        print(f"Error: train_weeks ({train_weeks}) + forecast_weeks ({forecast_weeks}) exceeds historicSalestoGenerate ({historicSalestoGenerate}).")
        return

    # File paths
    products_output = 'products2.csv'
    sales_output = 'sales2_financials.csv'

    # Load the preprocessed data with financials
    sales_financials_df = pd.read_csv(sales_output, parse_dates=['date'])

    # Merge with product data
    products_df = pd.read_csv(products_output)
    merged_df = sales_financials_df.merge(products_df, on='product_id', how='left')
    print("\nMerged DataFrame Info:")
    print(merged_df.info())

    # Check for any missing values after merge
    missing_values = merged_df.isnull().sum()
    print("\nMissing Values After Merge:")
    print(missing_values)

    # Handle any missing values if necessary
    # For this example, we'll drop any rows with missing values
    merged_df = merged_df.dropna()
    print("\nDataFrame after dropping missing values:")
    print(merged_df.info())

    # Select a sample product ID for demonstration
    sample_index = 100  # Change the index as needed to select different products
    unique_products = merged_df['product_id'].unique()
    if sample_index >= len(unique_products):
        print("Sample index out of range. Please choose a smaller index.")
        return

    sample_product_id = unique_products[sample_index]
    sample_product = merged_df[merged_df['product_id'] == sample_product_id].iloc[0]
    product_label = extract_product_label(sample_product['product_name'], sample_product['brand'])
    print(f"\nSelected Product for Forecasting: {product_label} (Product ID: {sample_product_id})")

    # Prepare training and testing data
    product_data = merged_df[merged_df['product_id'] == sample_product_id].sort_values('date')

    # Define training period and testing period
    train_data = product_data.iloc[:train_weeks]
    test_data = product_data.iloc[train_weeks:train_weeks + forecast_weeks]

    print(f"\nTraining Data: {len(train_data)} weeks")
    print(train_data[['date', 'weekly_sales']].head())
    print(f"\nTesting Data: {len(test_data)} weeks")
    print(test_data[['date', 'weekly_sales']].head())

    # Train and forecast using models
    print("\n--- ARIMA Model ---")
    arima_forecast = train_arima_model(train_data, test_data, product_label)

    print("\n--- Prophet Model ---")
    prophet_forecast = train_prophet_model(train_data, test_data, product_label)

    print("\n--- Random Forest Model ---")
    rf_forecast = train_random_forest_model(train_data, test_data, product_label)

    print("\n--- XGBoost Model ---")
    xgb_forecast = train_xgboost_model(train_data, test_data, product_label)

if __name__ == "__main__":
    main()

